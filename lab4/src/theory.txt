СИГНАЛЫ:

Сигналы в операционных системах, таких как Unix и Linux, используются для управления процессами и передачи информации о событиях. 
Вот подробное описание каждого из перечисленных сигналов:

1. SIGHUP (1)
Название: Hangup (зависание)

Описание: Сигнал SIGHUP обычно отправляется процессу, когда его управляющий терминал закрывается. 
Этот сигнал часто используется для перезапуска или перезагрузки процессов, особенно тех, которые работают в фоновом режиме (демонов). 
Например, многие серверные приложения перезагружают свои конфигурационные файлы при получении этого сигнала.

Действие по умолчанию: Завершение процесса.

2. SIGINT (2)
Название: Interrupt (прерывание)

Описание: Сигнал SIGINT отправляется процессу при нажатии комбинации клавиш Ctrl + C в терминале. 
Этот сигнал используется для "мягкого" прерывания выполнения процесса, позволяя ему корректно завершить свою работу.

Действие по умолчанию: Завершение процесса.

3. SIGQUIT (3)
Название: Quit (завершение)

Описание: Сигнал SIGQUIT отправляется процессу при нажатии комбинации клавиш Ctrl + \ (обратный слэш) в терминале. 
В отличие от SIGINT, этот сигнал также вызывает создание дампа ядра (core dump) процесса, что полезно для отладки.

Действие по умолчанию: Завершение процесса с созданием дампа ядра.

4. SIGILL (4)
Название: Illegal Instruction (недопустимая инструкция)

Описание: Сигнал SIGILL отправляется процессу, когда он пытается выполнить недопустимую инструкцию, например, инструкцию, которая не поддерживается процессором. 
Это может произойти, если программа была повреждена или содержит ошибки.

Действие по умолчанию: Завершение процесса с созданием дампа ядра.

5. SIGTERM (15)
Название: Termination (завершение)

Описание: Сигнал SIGTERM является сигналом "мягкого" завершения процесса. Он отправляется командой kill по умолчанию
 и позволяет процессу корректно завершить свою работу, сохранив данные и освободив ресурсы.

Действие по умолчанию: Завершение процесса.

6. SIGKILL (9)
Название: Kill (убийство)

Описание: Сигнал SIGKILL является самым мощным сигналом, который немедленно завершает процесс без возможности обработки этого сигнала самим процессом. 
Этот сигнал не может быть перехвачен или проигнорирован, поэтому он используется только в крайних случаях, когда другие сигналы не работают.

Действие по умолчанию: Немедленное завершение процесса.

7. SIGSTOP (19)
Название: Stop (остановка)

Описание: Сигнал SIGSTOP используется для приостановки выполнения процесса. В отличие от других сигналов, 
этот сигнал не может быть перехвачен или проигнорирован. Процесс останавливается до тех пор, пока не будет получен сигнал SIGCONT.

Действие по умолчанию: Приостановка процесса.

8. SIGCONT (18)
Название: Continue (продолжение)

Описание: Сигнал SIGCONT используется для возобновления выполнения приостановленного процесса. 
Этот сигнал может быть отправлен только процессу, который был приостановлен с помощью SIGSTOP или других сигналов остановки.

Действие по умолчанию: Возобновление выполнения процесса.

9. SIGTSTP (20)
Название: Terminal Stop (остановка терминала)

Описание: Сигнал SIGTSTP отправляется процессу при нажатии комбинации клавиш Ctrl + Z в терминале. 
Этот сигнал используется для приостановки выполнения процесса, но в отличие от SIGSTOP, процесс может перехватить и обработать этот сигнал.

Действие по умолчанию: Приостановка процесса.

10. SIGCHLD (17)
Название: Child (дочерний процесс)

Описание: Сигнал SIGCHLD отправляется родительскому процессу, когда один из его дочерних процессов завершается или останавливается. 
Этот сигнал используется для уведомления родительского процесса о состоянии дочерних процессов.

Действие по умолчанию: Игнорирование сигнала.


УТИЛИТА kill:

kill -сигнал pid_процесса
Отправляет сигнал процессу по PID, по умолчанию SIGTERM
Пример: kill -TERM 20446

ps - выведет PID запущенных процессов

pkill имя процесса
Отправит лигнал процессу по имени
Пример: pkill ping

pgrep имя процесса
Поиск PID по имени процесса
Пример: pgrep ping

killall имя процесса
Отсправит сигнал всем процессам с таким именем
Пример: killall ping


Неблокирующий wait c `WNOHANG`:

В Unix-подобных операционных системах, таких как Linux, функция wait используется для ожидания завершения дочерних процессов. 
Однако, если вы хотите выполнить неблокирующий вызов wait, то можете использовать опцию WNOHANG. 
Эта опция позволяет вызывать wait без блокировки, то есть функция вернет управление немедленно, даже если дочерний процесс еще не завершился.

Использование WNOHANG с waitpid
Функция waitpid является более гибкой версией wait и позволяет указать конкретный дочерний процесс для ожидания.

Использование опции WNOHANG с waitpid позволяет родительскому процессу ожидать завершения дочернего процесса без блокировки, 
что полезно в ситуациях, когда родительский процесс должен выполнять другие задачи параллельно.


Функция `alarm`, сигнал `SIGALRM`, функция `signal`:

Функция alarm планирует отправку сигнала SIGALRM через заданное количество секунд. 
Если вызов alarm выполняется несколько раз, предыдущий таймер отменяется, и устанавливается новый.

#include <unistd.h>
unsigned int alarm(unsigned int seconds);

Сигнал SIGALRM
Сигнал SIGALRM отправляется процессу, когда истекает время, заданное функцией alarm. 
По умолчанию, если не установлен обработчик сигнала, процесс завершается при получении SIGALRM.

Функция signal
Функция signal используется для установки обработчика сигнала. 
Обработчик сигнала — это функция, которая будет вызвана при получении определенного сигнала.

#include <signal.h>
void (*signal(int signum, void (*handler)(int)))(int);


Зомби процессы

ps aux | grep Z - вывести информацию о зомби процессах

Зомби процессы — это дочерние процессы, которые завершились, но их родительский процесс не вызвал функцию wait (или аналогичную) для получения статуса завершения. 
В результате, дочерний процесс остается в таблице процессов операционной системы как "зомби", занимая место в таблице процессов, но не выполняя никаких действий.

Как появляются зомби процессы:
Дочерний процесс завершается: Когда дочерний процесс завершается, он отправляет сигнал SIGCHLD родительскому процессу.
Родительский процесс не вызывает wait: Если родительский процесс не вызывает функцию wait (или аналогичную) для получения статуса завершения дочернего процесса, 
то дочерний процесс остается в таблице процессов как зомби.

Чем опасны зомби процессы:
Ограниченное количество процессов: Таблица процессов имеет ограниченный размер, и если зомби процессы занимают все доступные записи, новые процессы не смогут быть созданы.

Неиспользуемые ресурсы: Зомби процессы занимают место в таблице процессов, но не используют другие ресурсы, такие как память или процессорное время.

Как избавиться от зомби процессов:
Вызов wait или waitpid: Родительский процесс должен вызвать функцию wait или waitpid для получения статуса завершения дочернего процесса. 
Это позволит операционной системе удалить зомби процесс из таблицы процессов.

Использование signal(SIGCHLD, SIG_IGN): Если родительский процесс игнорирует сигнал SIGCHLD, операционная система автоматически удаляет зомби процессы.


Переменные etext, edata, и end являются глобальными переменными, которые указывают на определенные сегменты памяти процесса. 
Эти переменные обычно используются для демонстрации расположения различных частей памяти процесса.

1. etext

etext указывает на конец сегмента кода (текста) программы.
Этот сегмент содержит исполняемый код программы.

Пример:
printf("Address etext: %8X \n", &etext);

Пояснение:
Вывод адреса etext показывает, где заканчивается сегмент кода программы.
Этот адрес обычно соответствует последней инструкции в сегменте кода.

2. edata

edata указывает на конец сегмента данных программы.
Этот сегмент содержит инициализированные глобальные и статические переменные.

Пример:
printf("Address edata: %8X \n", &edata);
Пояснение:
Вывод адреса edata показывает, где заканчивается сегмент данных программы.
Этот адрес обычно соответствует последней инициализированной глобальной или статической переменной.

3. end
Описание:
end указывает на конец сегмента BSS (Block Started by Symbol) программы.
Этот сегмент содержит неинициализированные глобальные и статические переменные.

Пример:
printf("Address end  : %8X \n", &end);
Пояснение:
Вывод адреса end показывает, где заканчивается сегмент BSS программы.
Этот адрес обычно соответствует последней неинициализированной глобальной или статической переменной.


POSIX Threads: Создание и ожидание завершения

POSIX Threads (или Pthreads) — это стандарт для создания и управления потоками в многопоточных программах. 
Вот как можно создавать потоки и дожидаться их завершения:

Создание потока
Для создания потока используется функция pthread_create. Она принимает четыре аргумента:

Указатель на переменную типа pthread_t, которая будет содержать идентификатор созданного потока.

Указатель на структуру pthread_attr_t, которая определяет атрибуты потока (если атрибуты не нужны, передается NULL).

Указатель на функцию, которую будет выполнять поток.

Указатель на аргумент, который будет передан функции потока.

Ожидание завершения потока
Для ожидания завершения потока используется функция pthread_join. Она принимает два аргумента:

Идентификатор потока, который нужно дождаться.

Указатель на переменную, которая будет содержать возвращаемое значение потока (если не нужно, передается NULL).

Линковка с библиотекой pthread
Чтобы линковать программу с библиотекой pthread, нужно указать флаг -pthread при компиляции. 
Этот флаг включает поддержку многопоточности и линкует программу с библиотекой pthread.
