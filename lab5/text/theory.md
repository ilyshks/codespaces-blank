## Задание 1

Программа создает два потока, которые одновременно работают с общей переменной common.
Для синхронизации доступа к этой переменной используется мьютекс (pthread_mutex_t).
Однако, в данном примере блокировка мьютекса закомментирована, что может привести к состоянию гонки (race condition).

### Основные компоненты кода:
Глобальные переменные:

common: общая переменная, которая будет изменяться двумя потоками.

r1, r2, r3: переменные для хранения результатов работы потоков (не используются в данном примере).

pthread_mutex_t mut: мьютекс для синхронизации доступа к common.

Функции:

do_one_thing(int *): функция, которая будет выполняться в первом потоке.

do_another_thing(int *): функция, которая будет выполняться во втором потоке.

do_wrap_up(int): функция, которая будет выполнена после завершения обоих потоков.

Основная функция main:

Создаются два потока с помощью pthread_create.

Каждый поток выполняет свою функцию (do_one_thing или do_another_thing).

Потоки ожидаются с помощью pthread_join.

Вызывается функция do_wrap_up для вывода результата.

### Состояние гонки
Состояние гонки — это ошибка в многопоточном программировании, которая возникает, когда результат выполнения программы зависит от порядка или времени выполнения потоков. Это может привести к непредсказуемому поведению программы, так как потоки конкурируют за доступ к общим ресурсам (например, переменным, структурам данных, файлам и т.д.).

Причины возникновения состояния гонки:
Несинхронизированный доступ к общим ресурсам:

Если несколько потоков одновременно пытаются читать и записывать данные в общую переменную, результат может быть непредсказуемым.

Недетерминированный порядок выполнения:

Планировщик потоков операционной системы может переключать контекст между потоками в произвольные моменты времени, что приводит к недетерминированному порядку выполнения операций.

### Как предотвратить состояние гонки:
Использование мьютексов:

Мьютексы (или другие механизмы синхронизации) позволяют гарантировать, что только один поток может получить доступ к общему ресурсу в определенный момент времени.

pthread_mutex_lock(&mut);
// Критическая секция
pthread_mutex_unlock(&mut);

Использование атомарных операций:

В некоторых случаях можно использовать атомарные операции, которые гарантируют выполнение операции как единого неделимого шага.

Использование семафоров:

Семафоры — это еще один механизм синхронизации, который может использоваться для управления доступом к общим ресурсам.

### Линковка с библиотекой pthread
Чтобы линковать программу с библиотекой pthread, нужно указать флаг -pthread при компиляции. 
Этот флаг включает поддержку многопоточности и линкует программу с библиотекой pthread.

### Вывод
Без мьютекса:

Программа работает непредсказуемо из-за состояния гонки.

Значение common может быть меньше ожидаемого.

С мьютексом:

Программа работает предсказуемо, так как доступ к common синхронизирован.

Значение common увеличивается правильно.

## Задание 2

### Макрос PTHREAD_MUTEX_INITIALIZER:
PTHREAD_MUTEX_INITIALIZER — это макрос, который инициализирует мьютекс в состояние "не заблокирован".

Этот макрос подходит для статической инициализации мьютекса, когда мьютекс объявлен как глобальная или статическая переменная.

Что делает pthread_mutex_destroy?
pthread_mutex_destroy — это функция, которая освобождает любые ресурсы, связанные с мьютексом.

После вызова этой функции мьютекс становится недействительным и не может быть использован до тех пор, пока он не будет инициализирован снова.

## Задание 3

### Состояние deadlock
Состояние deadlock — это ситуация в многопоточном программировании, когда два или более потока находятся в состоянии ожидания ресурсов, 
занятых друг другом, и ни один из них не может продолжить выполнение. 

В результате все потоки остаются заблокированными навсегда.